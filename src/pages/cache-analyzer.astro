---
// Cache Performance Analyzer Page
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Cache Performance Analyzer</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }
        
        .test-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        button {
            padding: 15px 24px;
            border: none;
            border-radius: 10px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            background: #5a67d8;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        button.danger {
            background: #ef4444;
        }
        
        button.danger:hover {
            background: #dc2626;
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
        }
        
        button.success {
            background: #10b981;
        }
        
        button.success:hover {
            background: #059669;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .result-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            border-left: 5px solid #667eea;
            transition: transform 0.2s ease;
        }
        
        .result-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .result-card h3 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 15px;
        }
        
        .metric {
            background: white;
            padding: 18px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            transition: transform 0.2s ease;
        }
        
        .metric:hover {
            transform: scale(1.05);
        }
        
        .metric-label {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
        }
        
        .metric-value.fast { color: #10b981; }
        .metric-value.medium { color: #f59e0b; }
        .metric-value.slow { color: #ef4444; }
        
        .timeline {
            margin: 30px 0;
            padding: 25px;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            border-radius: 12px;
        }
        
        .timeline h3 {
            margin: 0 0 20px 0;
            color: #334155;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .timeline-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            transition: transform 0.2s ease;
        }
        
        .timeline-item:hover {
            transform: translateX(5px);
        }
        
        .timeline-item:last-child {
            margin-bottom: 0;
        }
        
        .timeline-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .timeline-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status {
            padding: 6px 14px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .status.hit { background: #d1fae5; color: #065f46; }
        .status.miss { background: #fee2e2; color: #991b1b; }
        .status.revalidate { background: #fef3c7; color: #92400e; }
        .status.error { background: #fde2e2; color: #991b1b; }
        
        .chart-container {
            margin: 30px 0;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }
        
        .chart-header h3 {
            margin: 0;
            color: #334155;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .chart-controls {
            display: flex;
            gap: 10px;
        }
        
        .chart-controls button {
            padding: 8px 16px;
            font-size: 0.85rem;
            background: #e2e8f0;
            color: #475569;
        }
        
        .chart-controls button.active {
            background: #667eea;
            color: white;
        }
        
        .chart-content {
            height: 250px;
            display: flex;
            align-items: end;
            justify-content: space-around;
            padding: 20px 0;
            border-bottom: 2px solid #e2e8f0;
            position: relative;
        }
        
        .bar {
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 6px 6px 0 0;
            margin: 0 3px;
            position: relative;
            min-width: 25px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .bar:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .bar-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: #666;
            font-weight: 500;
        }
        
        .bar-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            font-weight: 600;
            color: #333;
            background: white;
            padding: 2px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .recommendations {
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
            border: 1px solid #f59e0b;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
        }
        
        .recommendations h3 {
            color: #92400e;
            margin: 0 0 15px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .recommendations ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .recommendations li {
            margin-bottom: 10px;
            color: #78350f;
            line-height: 1.5;
        }
        
        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .endpoint-tests {
            margin: 30px 0;
            padding: 25px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }
        
        .endpoint-tests h3 {
            margin: 0 0 20px 0;
            color: #334155;
        }
        
        .endpoint-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .endpoint-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .endpoint-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.1);
        }
        
        .endpoint-card.testing {
            border-color: #f59e0b;
            background: #fffbeb;
        }
        
        .endpoint-card.success {
            border-color: #10b981;
            background: #ecfdf5;
        }
        
        .endpoint-card.error {
            border-color: #ef4444;
            background: #fef2f2;
        }
        
        .export-controls {
            margin: 30px 0;
            padding: 20px;
            background: #f1f5f9;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .export-controls h3 {
            margin: 0;
            color: #334155;
        }
        
        .export-buttons {
            display: flex;
            gap: 10px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .test-controls {
                grid-template-columns: 1fr;
            }
            
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            .export-controls {
                flex-direction: column;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Enhanced Cache Performance Analyzer</h1>
        <p class="subtitle">Comprehensive testing suite for Cloudflare Worker cache performance</p>
        
        <div class="test-controls">
            <button onclick="runSingleTest()">
                üéØ Single Test
            </button>
            <button onclick="runMultipleTests()">
                üìä 5x Sequential Tests
            </button>
            <button onclick="clearCacheAndTest()" class="danger">
                üóëÔ∏è Clear Cache & Test
            </button>
            <button onclick="runConcurrentTests()">
                ‚ö° 3x Concurrent Tests
            </button>
            <button onclick="testDifferentPages()">
                üìÑ Test Different Pages
            </button>
            <button onclick="runLoadTest()" class="success">
                üî• Load Test (10x)
            </button>
        </div>
        
        <div class="stats-summary">
            <div class="stat-card">
                <div class="stat-value" id="total-tests">0</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avg-response">-</div>
                <div class="stat-label">Avg Response</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="cache-hit-rate">-</div>
                <div class="stat-label">Cache Hit Rate</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="success-rate">-</div>
                <div class="stat-label">Success Rate</div>
            </div>
        </div>
        
        <div class="results-grid">
            <div class="result-card">
                <h3>üìà Latest Test Results</h3>
                <div id="latest-results">
                    <p style="color: #666; text-align: center;">Run a test to see results</p>
                </div>
            </div>
            
            <div class="result-card">
                <h3>üß† Cache Analysis</h3>
                <div id="cache-analysis">
                    <p style="color: #666; text-align: center;">No data yet</p>
                </div>
            </div>
            
            <div class="result-card">
                <h3>üåç Geographic Performance</h3>
                <div id="geo-analysis">
                    <p style="color: #666; text-align: center;">No data yet</p>
                </div>
            </div>
        </div>
        
        <div class="endpoint-tests">
            <h3>üîç Worker Endpoint Tests</h3>
            <div class="endpoint-grid">
                <div class="endpoint-card" onclick="testEndpoint('/__health')">
                    <strong>Health Check</strong>
                    <div id="health-status">Not tested</div>
                </div>
                <div class="endpoint-card" onclick="testEndpoint('/__metrics')">
                    <strong>Metrics</strong>
                    <div id="metrics-status">Not tested</div>
                </div>
                <div class="endpoint-card" onclick="testEndpoint('/__perf-debug')">
                    <strong>Performance Debug</strong>
                    <div id="perf-debug-status">Not tested</div>
                </div>
                <div class="endpoint-card" onclick="testEndpoint('/__cache-debug')">
                    <strong>Cache Debug</strong>
                    <div id="cache-debug-status">Not tested</div>
                </div>
            </div>
        </div>
        
        <div class="chart-container">
            <div class="chart-header">
                <h3>üìä Performance Visualization</h3>
                <div class="chart-controls">
                    <button class="active" onclick="switchChart('response')">Response Time</button>
                    <button onclick="switchChart('cache')">Cache Status</button>
                    <button onclick="switchChart('timeline')">Timeline</button>
                </div>
            </div>
            <div class="chart-content" id="performance-chart">
                <div style="width: 100%; text-align: center; color: #666; padding: 60px 0;">
                    üìä Run tests to see performance visualization
                </div>
            </div>
        </div>
        
        <div class="timeline" id="test-timeline">
            <h3>‚è±Ô∏è Test Timeline</h3>
            <div id="timeline-content">
                <p style="color: #666; text-align: center;">No tests run yet</p>
            </div>
        </div>
        
        <div class="export-controls">
            <h3>üì§ Export & Analysis</h3>
            <div class="export-buttons">
                <button onclick="exportResults('json')">Export JSON</button>
                <button onclick="exportResults('csv')">Export CSV</button>
                <button onclick="generateReport()">Generate Report</button>
                <button onclick="clearAllData()" class="danger">Clear All Data</button>
            </div>
        </div>
        
        <div class="recommendations" id="recommendations" style="display: none;">
            <h3>üí° Performance Recommendations</h3>
            <ul id="rec-list"></ul>
        </div>
    </div>

    <script>
        // Global variables
        const BASE_URL = window.location.origin;
        const TEST_URLS = [
            '/ÿ¥ÿ±ŸÉÿßÿ™-ÿ™ÿØÿßŸàŸÑ-ŸÖÿ±ÿÆÿµÿ©-ŸÅŸä-ÿßŸÑÿ≥ÿπŸàÿØŸäÿ©',
            '/reviews',
            '/ŸÖŸÜÿµÿßÿ™-ÿ™ÿØÿßŸàŸÑ-ÿßŸÑÿπŸÖŸÑÿßÿ™-ÿßŸÑÿ±ŸÇŸÖŸäÿ©-ŸÅŸä-ÿßŸÑÿ•ŸÖÿßÿ±ÿßÿ™'
        ];
        
        let testHistory = [];
        let currentChart = 'response';
        let endpointResults = {};
        
        // Load saved data on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadSavedData();
            updateAllDisplays();
        });
        
        function loadSavedData() {
            const saved = localStorage.getItem('cacheAnalyzerData');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    testHistory = data.testHistory || [];
                    endpointResults = data.endpointResults || {};
                } catch (e) {
                    console.error('Error loading saved data:', e);
                }
            }
        }
        
        function saveData() {
            const data = {
                testHistory,
                endpointResults,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('cacheAnalyzerData', JSON.stringify(data));
        }
        
        async function measureRequest(url, options = {}) {
            const startTime = performance.now();
            
            try {
                const response = await fetch(url, {
                    cache: 'no-store',
                    ...options
                });
                
                const endTime = performance.now();
                const responseTime = Math.round(endTime - startTime);
                
                return {
                    url,
                    responseTime,
                    status: response.status,
                    size: response.headers.get('content-length') || 'unknown',
                    cacheStatus: response.headers.get('cf-cache-status') || response.headers.get('x-cache-hit') === 'true' ? 'HIT' : 'MISS',
                    serverTiming: response.headers.get('server-timing') || 'none',
                    country: response.headers.get('x-country-code') || 'unknown',
                    processingTime: response.headers.get('x-processing-time') || 'unknown',
                    brokerCount: response.headers.get('x-broker-count') || 'unknown',
                    timestamp: new Date().toISOString(),
                    success: response.ok
                };
            } catch (error) {
                const endTime = performance.now();
                return {
                    url,
                    responseTime: Math.round(endTime - startTime),
                    status: 0,
                    size: 'error',
                    cacheStatus: 'error',
                    serverTiming: 'none',
                    country: 'unknown',
                    processingTime: 'error',
                    brokerCount: 'error',
                    timestamp: new Date().toISOString(),
                    error: error.message,
                    success: false
                };
            }
        }
        
        // Global function declarations
        window.runSingleTest = async function() {
            updateButton('runSingleTest()', true);
            
            const url = `${BASE_URL}${TEST_URLS[0]}?t=${Date.now()}`;
            const result = await measureRequest(url);
            
            testHistory.push(result);
            updateAllDisplays();
            saveData();
            
            updateButton('runSingleTest()', false);
        };
        
        window.runMultipleTests = async function() {
            updateButton('runMultipleTests()', true);
            
            for (let i = 0; i < 5; i++) {
                const url = `${BASE_URL}${TEST_URLS[0]}?t=${Date.now()}-${i}`;
                const result = await measureRequest(url);
                result.note = `Sequential ${i + 1}`;
                testHistory.push(result);
                
                updateAllDisplays();
                saveData();
                
                if (i < 4) await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            updateButton('runMultipleTests()', false);
        };
        
        window.clearCacheAndTest = async function() {
            updateButton('clearCacheAndTest()', true);
            
            try {
                await fetch(`${BASE_URL}/__purge-cache`, {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer dfdf76dfdfyuh343kfd63hje3',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const url = `${BASE_URL}${TEST_URLS[0]}?cleared=${Date.now()}`;
                const result = await measureRequest(url);
                
                result.note = 'After cache clear';
                testHistory.push(result);
                updateAllDisplays();
                saveData();
                
            } catch (error) {
                console.error('Cache clear failed:', error);
                await window.runSingleTest();
            }
            
            updateButton('clearCacheAndTest()', false);
        };
        
        window.runConcurrentTests = async function() {
            updateButton('runConcurrentTests()', true);
            
            const promises = [];
            for (let i = 0; i < 3; i++) {
                const url = `${BASE_URL}${TEST_URLS[0]}?concurrent=${Date.now()}-${i}`;
                promises.push(measureRequest(url));
            }
            
            const results = await Promise.all(promises);
            
            results.forEach((result, i) => {
                result.note = `Concurrent ${i + 1}`;
                testHistory.push(result);
            });
            
            updateAllDisplays();
            saveData();
            updateButton('runConcurrentTests()', false);
        };
        
        window.testDifferentPages = async function() {
            updateButton('testDifferentPages()', true);
            
            for (let i = 0; i < TEST_URLS.length; i++) {
                const url = `${BASE_URL}${TEST_URLS[i]}?page-test=${Date.now()}`;
                const result = await measureRequest(url);
                result.note = `Page ${i + 1}: ${TEST_URLS[i].split('/').pop()}`;
                testHistory.push(result);
                
                updateAllDisplays();
                saveData();
                
                if (i < TEST_URLS.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            updateButton('testDifferentPages()', false);
        };
        
        window.runLoadTest = async function() {
            updateButton('runLoadTest()', true);
            
            const batchSize = 5;
            const totalTests = 10;
            
            for (let batch = 0; batch < totalTests / batchSize; batch++) {
                const promises = [];
                
                for (let i = 0; i < batchSize; i++) {
                    const testNum = batch * batchSize + i + 1;
                    const url = `${BASE_URL}${TEST_URLS[0]}?load-test=${Date.now()}-${testNum}`;
                    promises.push(measureRequest(url));
                }
                
                const results = await Promise.all(promises);
                
                results.forEach((result, i) => {
                    const testNum = batch * batchSize + i + 1;
                    result.note = `Load Test ${testNum}`;
                    testHistory.push(result);
                });
                
                updateAllDisplays();
                saveData();
                
                if (batch < (totalTests / batchSize) - 1) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
            
            updateButton('runLoadTest()', false);
        };
        
        window.testEndpoint = async function(endpoint) {
            const card = document.querySelector(`[onclick="testEndpoint('${endpoint}')"]`);
            const statusDiv = card.querySelector('div:last-child');
            
            card.className = 'endpoint-card testing';
            statusDiv.innerHTML = '<span class="loading"></span>Testing...';
            
            try {
                const startTime = performance.now();
                const response = await fetch(`${BASE_URL}${endpoint}`);
                const endTime = performance.now();
                const responseTime = Math.round(endTime - startTime);
                
                const result = {
                    endpoint,
                    responseTime,
                    status: response.status,
                    success: response.ok,
                    timestamp: new Date().toISOString()
                };
                
                endpointResults[endpoint] = result;
                
                if (response.ok) {
                    card.className = 'endpoint-card success';
                    statusDiv.innerHTML = `‚úÖ ${responseTime}ms`;
                } else {
                    card.className = 'endpoint-card error';
                    statusDiv.innerHTML = `‚ùå ${response.status}`;
                }
                
            } catch (error) {
                card.className = 'endpoint-card error';
                statusDiv.innerHTML = `‚ùå Error`;
                endpointResults[endpoint] = {
                    endpoint,
                    error: error.message,
                    success: false,
                    timestamp: new Date().toISOString()
                };
            }
            
            saveData();
        };
        
        window.switchChart = function(type) {
            currentChart = type;
            
            // Update button states
            document.querySelectorAll('.chart-controls button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updateChart();
        };
        
        window.exportResults = function(format) {
            if (testHistory.length === 0) {
                alert('No data to export. Run some tests first!');
                return;
            }
            
            let content, filename, mimeType;
            
            if (format === 'json') {
                content = JSON.stringify({
                    testHistory,
                    endpointResults,
                    exportDate: new Date().toISOString(),
                    summary: {
                        totalTests: testHistory.length,
                        avgResponseTime: Math.round(testHistory.reduce((sum, t) => sum + t.responseTime, 0) / testHistory.length),
                        hitRate: Math.round(testHistory.filter(t => t.cacheStatus === 'HIT').length / testHistory.length * 100),
                        successRate: Math.round(testHistory.filter(t => t.success).length / testHistory.length * 100)
                    }
                }, null, 2);
                filename = `cache-analysis-${new Date().toISOString().split('T')[0]}.json`;
                mimeType = 'application/json';
            } else if (format === 'csv') {
                const headers = ['Timestamp', 'URL', 'Response Time (ms)', 'Cache Status', 'Status Code', 'Country', 'Note'];
                const rows = testHistory.map(test => [
                    test.timestamp,
                    test.url,
                    test.responseTime,
                    test.cacheStatus,
                    test.status,
                    test.country,
                    test.note || ''
                ]);
                
                content = [headers, ...rows].map(row => row.join(',')).join('\n');
                filename = `cache-analysis-${new Date().toISOString().split('T')[0]}.csv`;
                mimeType = 'text/csv';
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };
        
        window.generateReport = function() {
            if (testHistory.length === 0) {
                alert('No data available for report generation.');
                return;
            }
            
            const recent = testHistory.slice(-50);
            const avgTime = Math.round(recent.reduce((sum, t) => sum + t.responseTime, 0) / recent.length);
            const hitRate = Math.round(recent.filter(t => t.cacheStatus === 'HIT').length / recent.length * 100);
            const successRate = Math.round(recent.filter(t => t.success).length / recent.length * 100);
            
            const report = `
# Cache Performance Analysis Report

Generated: ${new Date().toLocaleString()}

## Summary Statistics
- **Total Tests**: ${testHistory.length}
- **Average Response Time**: ${avgTime}ms
- **Cache Hit Rate**: ${hitRate}%
- **Success Rate**: ${successRate}%

## Performance Analysis
${avgTime < 200 ? '‚úÖ **Excellent Performance** - Response times are very fast' :
  avgTime < 500 ? '‚ö†Ô∏è **Good Performance** - Response times are acceptable but could be improved' :
  '‚ùå **Poor Performance** - Response times need optimization'}

${hitRate > 80 ? '‚úÖ **Excellent Cache Efficiency** - Very high hit rate' :
  hitRate > 60 ? '‚ö†Ô∏è **Moderate Cache Efficiency** - Cache hit rate could be improved' :
  '‚ùå **Poor Cache Efficiency** - Low hit rate indicates caching issues'}

## Recommendations
${avgTime > 500 ? '- Optimize database queries and implement query caching\\n' : ''}
${hitRate < 60 ? '- Review cache TTL settings and cache key strategies\\n' : ''}
${successRate < 95 ? '- Investigate and resolve error conditions\\n' : ''}
- Monitor performance trends over time
- Consider implementing cache warming strategies
- Review geographic performance variations

## Recent Test History
${recent.slice(-10).map((test, i) => 
`${i + 1}. ${test.responseTime}ms - ${test.cacheStatus} - ${new Date(test.timestamp).toLocaleTimeString()}`
).join('\\n')}

---
*Report generated by Enhanced Cache Performance Analyzer*
            `.trim();
            
            const blob = new Blob([report], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cache-performance-report-${new Date().toISOString().split('T')[0]}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };
        
        window.clearAllData = function() {
            if (confirm('Are you sure you want to clear all test data? This cannot be undone.')) {
                testHistory = [];
                endpointResults = {};
                localStorage.removeItem('cacheAnalyzerData');
                location.reload();
            }
        };
        
        function updateButton(onclick, loading) {
            document.querySelectorAll('button').forEach(btn => {
                if (btn.onclick && btn.onclick.toString().includes(onclick)) {
                    btn.disabled = loading;
                    if (loading) {
                        btn.innerHTML = '<span class="loading"></span>Running...';
                    } else {
                        // Restore original text
                        location.reload();
                    }
                }
            });
        }
        
        function updateAllDisplays() {
            updateStats();
            updateResults();
            updateCacheAnalysis();
            updateGeoAnalysis();
            updateTimeline();
            updateChart();
            updateRecommendations();
        }
        
        function updateStats() {
            const total = testHistory.length;
            const successful = testHistory.filter(t => t.success).length;
            const avgResponse = total > 0 ? Math.round(testHistory.reduce((sum, t) => sum + t.responseTime, 0) / total) : 0;
            const hitRate = total > 0 ? Math.round(testHistory.filter(t => t.cacheStatus === 'HIT').length / total * 100) : 0;
            const successRate = total > 0 ? Math.round(successful / total * 100) : 0;
            
            document.getElementById('total-tests').textContent = total;
            document.getElementById('avg-response').textContent = total > 0 ? `${avgResponse}ms` : '-';
            document.getElementById('cache-hit-rate').textContent = total > 0 ? `${hitRate}%` : '-';
            document.getElementById('success-rate').textContent = total > 0 ? `${successRate}%` : '-';
        }
        
        function updateResults() {
            if (testHistory.length === 0) return;
            
            const container = document.getElementById('latest-results');
            const latest = testHistory[testHistory.length - 1];
            
            const speedClass = latest.responseTime < 200 ? 'fast' : 
                             latest.responseTime < 500 ? 'medium' : 'slow';
            
            container.innerHTML = `
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Response Time</div>
                        <div class="metric-value ${speedClass}">${latest.responseTime}ms</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Cache Status</div>
                        <div class="metric-value">${latest.cacheStatus}</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Status Code</div>
                        <div class="metric-value">${latest.status}</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Processing</div>
                        <div class="metric-value">${latest.processingTime}</div>
                    </div>
                </div>
            `;
        }
        
        function updateCacheAnalysis() {
            if (testHistory.length === 0) return;
            
            const recent = testHistory.slice(-10);
            const hitRate = recent.filter(t => t.cacheStatus === 'HIT').length / recent.length * 100;
            const avgTime = recent.reduce((sum, t) => sum + t.responseTime, 0) / recent.length;
            const variance = Math.max(...recent.map(t => t.responseTime)) - Math.min(...recent.map(t => t.responseTime));
            
            const container = document.getElementById('cache-analysis');
            container.innerHTML = `
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Hit Rate</div>
                        <div class="metric-value">${Math.round(hitRate)}%</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Avg Time</div>
                        <div class="metric-value">${Math.round(avgTime)}ms</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Variance</div>
                        <div class="metric-value">${variance}ms</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Tests</div>
                        <div class="metric-value">${recent.length}</div>
                    </div>
                </div>
            `;
        }
        
        function updateGeoAnalysis() {
            if (testHistory.length === 0) return;
            
            const countries = {};
            testHistory.forEach(test => {
                if (test.country && test.country !== 'unknown') {
                    if (!countries[test.country]) {
                        countries[test.country] = { count: 0, totalTime: 0 };
                    }
                    countries[test.country].count++;
                    countries[test.country].totalTime += test.responseTime;
                }
            });
            
            const container = document.getElementById('geo-analysis');
            const countryEntries = Object.entries(countries);
            
            if (countryEntries.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center;">No geographic data available</p>';
                return;
            }
            
            container.innerHTML = `
                <div class="metrics">
                    ${countryEntries.slice(0, 4).map(([country, data]) => `
                        <div class="metric">
                            <div class="metric-label">${country}</div>
                            <div class="metric-value">${Math.round(data.totalTime / data.count)}ms</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        function updateTimeline() {
            if (testHistory.length === 0) return;
            
            const container = document.getElementById('timeline-content');
            const recent = testHistory.slice(-15).reverse();
            
            container.innerHTML = recent.map((test, i) => {
                const statusClass = test.cacheStatus === 'HIT' ? 'hit' : 
                                   test.cacheStatus === 'MISS' ? 'miss' : 
                                   test.cacheStatus === 'error' ? 'error' : 'revalidate';
                
                const timeAgo = new Date(test.timestamp).toLocaleTimeString();
                
                return `
                    <div class="timeline-item">
                        <div class="timeline-left">
                            <strong>${test.responseTime}ms</strong>
                            <small>${test.note || 'Standard test'} ‚Ä¢ ${timeAgo}</small>
                        </div>
                        <div class="timeline-right">
                            <span class="status ${statusClass}">${test.cacheStatus}</span>
                            ${test.country !== 'unknown' ? `<small>${test.country}</small>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateChart() {
            const container = document.getElementById('performance-chart');
            
            if (testHistory.length === 0) {
                container.innerHTML = `
                    <div style="width: 100%; text-align: center; color: #666; padding: 60px 0;">
                        üìä Run tests to see performance visualization
                    </div>
                `;
                return;
            }
            
            const recent = testHistory.slice(-20);
            
            if (currentChart === 'response') {
                updateResponseChart(container, recent);
            } else if (currentChart === 'cache') {
                updateCacheChart(container, recent);
            } else if (currentChart === 'timeline') {
                updateTimelineChart(container, recent);
            }
        }
        
        function updateResponseChart(container, data) {
            const maxTime = Math.max(...data.map(t => t.responseTime));
            
            container.innerHTML = data.map((test, i) => {
                const height = (test.responseTime / maxTime) * 200;
                const color = test.responseTime < 200 ? '#10b981' : 
                             test.responseTime < 500 ? '#f59e0b' : '#ef4444';
                
                return `
                    <div class="bar" style="height: ${height}px; background: ${color};" title="${test.note || 'Test'}: ${test.responseTime}ms">
                        <div class="bar-value">${test.responseTime}ms</div>
                        <div class="bar-label">T${i + 1}</div>
                    </div>
                `;
            }).join('');
        }
        
        function updateCacheChart(container, data) {
            const hitCount = data.filter(t => t.cacheStatus === 'HIT').length;
            const missCount = data.filter(t => t.cacheStatus === 'MISS').length;
            const errorCount = data.filter(t => t.cacheStatus === 'error').length;
            
            const total = data.length;
            const hitHeight = (hitCount / total) * 200;
            const missHeight = (missCount / total) * 200;
            const errorHeight = (errorCount / total) * 200;
            
            container.innerHTML = `
                <div class="bar" style="height: ${hitHeight}px; background: #10b981;" title="Cache Hits: ${hitCount}">
                    <div class="bar-value">${hitCount}</div>
                    <div class="bar-label">HIT</div>
                </div>
                <div class="bar" style="height: ${missHeight}px; background: #f59e0b;" title="Cache Misses: ${missCount}">
                    <div class="bar-value">${missCount}</div>
                    <div class="bar-label">MISS</div>
                </div>
                <div class="bar" style="height: ${errorHeight}px; background: #ef4444;" title="Errors: ${errorCount}">
                    <div class="bar-value">${errorCount}</div>
                    <div class="bar-label">ERROR</div>
                </div>
            `;
        }
        
        function updateTimelineChart(container, data) {
            container.innerHTML = `
                <div style="width: 100%; text-align: center; color: #666; padding: 60px 0;">
                    üìà Timeline view showing ${data.length} recent tests
                    <br><small>Average: ${Math.round(data.reduce((sum, t) => sum + t.responseTime, 0) / data.length)}ms</small>
                </div>
            `;
        }
        
        function updateRecommendations() {
            if (testHistory.length < 3) return;
            
            const recent = testHistory.slice(-10);
            const avgTime = recent.reduce((sum, t) => sum + t.responseTime, 0) / recent.length;
            const hitRate = recent.filter(t => t.cacheStatus === 'HIT').length / recent.length * 100;
            const errorRate = recent.filter(t => !t.success).length / recent.length * 100;
            
            const recommendations = [];
            
            if (avgTime > 1000) {
                recommendations.push('Average response time is very slow (>1s). Consider optimizing database queries and implementing more aggressive caching.');
            } else if (avgTime > 500) {
                recommendations.push('Response time could be improved. Check for database bottlenecks and optimize query performance.');
            } else if (avgTime < 200) {
                recommendations.push('Excellent response times! Your optimizations are working well.');
            }
            
            if (hitRate < 30) {
                recommendations.push('Very low cache hit rate. Verify cache headers, TTL settings, and ensure cache keys are consistent.');
            } else if (hitRate < 60) {
                recommendations.push('Moderate cache hit rate. Consider increasing cache TTL or warming cache more frequently.');
            } else if (hitRate > 80) {
                recommendations.push('Excellent cache performance! Consider fine-tuning TTL values for even better efficiency.');
            }
            
            if (errorRate > 5) {
                recommendations.push('High error rate detected. Check server logs and ensure all dependencies are healthy.');
            }
            
            const variance = Math.max(...recent.map(t => t.responseTime)) - Math.min(...recent.map(t => t.responseTime));
            if (variance > 1000) {
                recommendations.push('High response time variance suggests inconsistent performance. Monitor database and worker performance.');
            }
            
            if (recommendations.length > 0) {
                document.getElementById('recommendations').style.display = 'block';
                document.getElementById('rec-list').innerHTML = recommendations.map(r => `<li>${r}</li>`).join('');
            }
        }
    </script>
</body>
</html>
